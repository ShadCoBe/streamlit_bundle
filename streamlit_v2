# LAUNCH_app.py — iso/subprocess (empêche les superpositions)
import os, sys, subprocess, shlex

def resource_path(rel: str) -> str:
    base = getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base, rel)

if __name__ == "__main__":
    base = getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))
    os.chdir(base)

    app_path = resource_path("app.py")

    # options streamlit pour un .exe
    flags = {
        "server.headless": "true",
        "server.address": "127.0.0.1",
        "server.port": "8502",
        "browser.gatherUsageStats": "false",
        "server.runOnSave": "false",
        "server.fileWatcherType": "none",
        "server.enableCORS": "false",
        "server.enableXsrfProtection": "false",
    }

    # transforme flags en arguments CLI: --key=value
    cli_flags = " ".join(f"--{k}={v}" for k, v in flags.items())

    # lance streamlit dans un process séparé → pas de pollution/imports partagés
    cmd = f"{sys.executable} -m streamlit run {shlex.quote(app_path)} {cli_flags}"
    try:
        subprocess.run(cmd, check=True, shell=True, cwd=base)
    except subprocess.CalledProcessError as e:
        # si tu veux, remets un print simple au lieu d'un input bloquant
        print("Erreur de lancement Streamlit:", e)
        sys.exit(e.returncode)

# LAUNCH_app.py — furtif + logs + URL personnalisée
import os, sys, subprocess, socket, time, webbrowser

# === PERSONNALISATION ICI ===
HOST = "localhost"   # ou "127.0.0.1"
PORT = 8502
PUBLIC_URL = None     # ex: "http://monapp.local" si tu as un DNS/hosts/proxy
OPEN_PUBLIC_URL = True  # si PUBLIC_URL défini, ouvrir cette URL (sinon localhost:PORT)
# ============================

def here() -> str:
    return getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))

def resource_path(*parts: str) -> str:
    return os.path.join(here(), *parts)

def wait_for_port(host: str, port: int, timeout: float = 25.0) -> bool:
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            with socket.create_connection((host, port), timeout=1.0):
                return True
        except OSError:
            time.sleep(0.2)
    return False

def open_url(url: str):
    try:
        if webbrowser.open_new(url):
            return
    except Exception:
        pass
    if os.name == "nt":
        try:
            os.startfile(url)  # type: ignore[attr-defined]
            return
        except Exception:
            pass
        try:
            subprocess.Popen(["cmd", "/c", "start", "", url], shell=True)
            return
        except Exception:
            pass
    print(f"[launcher] Ouvre manuellement : {url}")

if __name__ == "__main__":
    base = here()
    os.chdir(base)

    app_path = resource_path("app.py")
    url_local = f"http://{HOST}:{PORT}"
    url_to_open = PUBLIC_URL if (PUBLIC_URL and OPEN_PUBLIC_URL) else url_local

    # Flags Streamlit (rapides, pas de watcher)
    flags = {
        "server.headless": "true",           # on ouvre le navigateur nous-mêmes
        "server.address": HOST,
        "server.port": str(PORT),
        "browser.gatherUsageStats": "false",
        "server.runOnSave": "false",
        "server.fileWatcherType": "none",
        "server.enableCORS": "false",
        "server.enableXsrfProtection": "false",
    }

    env = os.environ.copy()
    env["PYTHONPATH"] = base
    env["STREAMLIT_LAUNCHED_FROM_EXE"] = "1"

    # Utiliser pythonw.exe (Windows) pour éviter toute console
    py_exec = sys.executable
    if os.name == "nt" and py_exec.lower().endswith("python.exe"):
        pyw = py_exec[:-10] + "pythonw.exe"
        if os.path.exists(pyw):
            py_exec = pyw

    cmd = [py_exec, "-m", "streamlit", "run", app_path] + [f"--{k}={v}" for k, v in flags.items()]

    # LOGS -> run.log (stdout+stderr)
    log_path = os.path.join(base, "run.log")
    log_file = open(log_path, "a", encoding="utf-8")  # ne pas fermer tout de suite (process enfant l’utilise)

    # Démarre Streamlit en arrière-plan, silencieux, sans fenêtre
    kwargs = dict(cwd=base, env=env, stdout=log_file, stderr=subprocess.STDOUT)
    if os.name == "nt":
        si = subprocess.STARTUPINFO()
        si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        kwargs["startupinfo"] = si

    subprocess.Popen(cmd, **kwargs)

    # Attendre que le serveur démarre puis ouvrir le navigateur
    if wait_for_port(HOST, PORT, timeout=25):
        open_url(url_to_open)
    else:
        # on log l’info si jamais
        try:
            log_file.write(f"\n[launcher] Server not reachable on {url_local}\n")
            log_file.flush()
        except Exception:
            pass

    # fermer le launcher (le process Streamlit continue)
    # on NE ferme PAS log_file ici; il est utilisé par le sous-processus
    # le système libérera le handle quand le sous-processus se termine
    sys.exit(0)

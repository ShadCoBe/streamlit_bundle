# LAUNCH_app.py — furtif + ouverture unique (anti-boucle)
import os, sys, subprocess, socket, time, webbrowser, tempfile

# ====== PARAMS ======
HOST = "localhost"
PORT = 8502
OPEN_PUBLIC_URL = None   # ex: "http://monapp.local" si tu as DNS/hosts/proxy
TIMEOUT_READY = 25.0     # secondes d'attente du serveur
# ====================

def here() -> str:
    return getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))

def resource_path(*parts: str) -> str:
    return os.path.join(here(), *parts)

def wait_for_port(host: str, port: int, timeout: float) -> bool:
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            with socket.create_connection((host, port), timeout=1.0):
                return True
        except OSError:
            time.sleep(0.2)
    return False

def port_is_open(host: str, port: int) -> bool:
    try:
        with socket.create_connection((host, port), timeout=0.8):
            return True
    except OSError:
        return False

def open_url(url: str):
    try:
        if webbrowser.open_new(url):
            return
    except Exception:
        pass
    if os.name == "nt":
        try:
            os.startfile(url)  # type: ignore[attr-defined]
            return
        except Exception:
            pass
        try:
            subprocess.Popen(["cmd", "/c", "start", "", url], shell=True)
            return
        except Exception:
            pass
    # fallback silencieux : rien

if __name__ == "__main__":
    base = here()
    os.chdir(base)

    app_path = resource_path("app.py")
    local_url = f"http://{HOST}:{PORT}"
    url_to_open = OPEN_PUBLIC_URL or local_url

    # --- Flag d'ouverture unique lié au port ---
    flag_path = os.path.join(tempfile.gettempdir(), f"streamlit_opened_{PORT}.flag")
    # Si le port n'est pas ouvert, on réinitialise le flag pour autoriser une future ouverture
    if not port_is_open(HOST, PORT) and os.path.exists(flag_path):
        try:
            os.remove(flag_path)
        except Exception:
            pass

    # --- Prépare lancement streamlit ---
    flags = {
        "server.headless": "true",           # on ouvre nous-mêmes le navigateur
        "server.address": HOST,
        "server.port": str(PORT),
        "browser.gatherUsageStats": "false",
        "server.runOnSave": "false",
        "server.fileWatcherType": "none",
        "server.enableCORS": "false",
        "server.enableXsrfProtection": "false",
    }

    env = os.environ.copy()
    env["PYTHONPATH"] = base
    env["STREAMLIT_LAUNCHED_FROM_EXE"] = "1"

    # Utiliser pythonw.exe si dispo (Windows) pour ne pas afficher de console
    py_exec = sys.executable
    if os.name == "nt" and py_exec.lower().endswith("python.exe"):
        pyw = py_exec[:-10] + "pythonw.exe"
        if os.path.exists(pyw):
            py_exec = pyw

    cmd = [py_exec, "-m", "streamlit", "run", app_path] + [f"--{k}={v}" for k, v in flags.items()]

    # Lance en arrière-plan, furtif
    kwargs = dict(cwd=base, env=env)
    if os.name == "nt":
        si = subprocess.STARTUPINFO()
        si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        kwargs["startupinfo"] = si
        kwargs["stdout"] = subprocess.DEVNULL
        kwargs["stderr"] = subprocess.DEVNULL

    subprocess.Popen(cmd, **kwargs)

    # Attends que le serveur soit prêt
    if wait_for_port(HOST, PORT, TIMEOUT_READY):
        # Ouvre **une seule fois** par “cycle de serveur”
        if not os.path.exists(flag_path):
            try:
                with open(flag_path, "w", encoding="utf-8") as f:
                    f.write("opened")
            except Exception:
                pass
            open_url(url_to_open)
    # Le launcher se ferme immédiatement (le serveur continue)
    sys.exit(0)
